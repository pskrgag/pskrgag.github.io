[{"content":"Intro Recently I have started to learn Haskell at my spare time by solving codewars problems time-to-time. This post is about my solution for this kata, since I was impressed by power of applicative parsing and want to document things I have learned during solving.\nNOTE: I am no way an expert in Haskell or FP languages, so my solution might be not the best/cleanest/etc.\nThe task The task is simple: implement a parser for a subset of JSON. The only big difference from real json is no support for exponential numbers and unicode characters.\nLanguage task suggest to implement has following (BNF)[https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form]:\nstring ::= \u0026quot;\u0026quot; | \u0026quot;chars\u0026quot; chars ::= char | char chars char ::= \u0026lt;ASCII character except for \u0026quot;\u0026gt; number ::= int | int frac | '-' number int ::= digits frac ::= '.' digits digits ::= digit | digit digits digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '0' object ::= \u0026quot;{}\u0026quot; | '{' members '}' members ::= pair | pair ',' members pair ::= string ':' value array ::= \u0026quot;[]\u0026quot; | '[' elements ']' elements ::= value | value ',' elements value = string | number | object | array | \u0026quot;true\u0026quot; | \u0026quot;false\u0026quot; | \u0026quot;null\u0026quot; White-space characters are ignored.\nAnd it\u0026rsquo;s required to implement function f :: String -\u0026gt; Value, where Value defined as follows:\ndata Value = String String | Number Double | Object [(Value, Value)] -- an association list -- only a `String` is valid as the index `Value` | Array [Value] -- not limited to identical primitive datatypes | Boolean Bool -- either `True` or `False` | Null deriving (Show) Applicative Parser Parser by its nature is a function that takes an input string and produces some value, leaving unparsed string untouched. Based on this parser type is defined as following:\nnewtype Parser a = Parser {runParser :: String -\u0026gt; Maybe (a, String)} runParser is a function that consumes part of the input string and maybe produces pair of value of type a and rest of the unparsed string. In our case generic type a will be a Value introduced in previous paragraph.\nBasic Parsing Using type introduced above it\u0026rsquo;s possible to start parsing right away. The easiest thing to implement is to parser for character by predicate\nparseCond :: (Char -\u0026gt; Bool) -\u0026gt; Parser Char parseCond fn = Parser helper where helper [] = Nothing helper (x : xs) | fn x = Just (x, xs) | otherwise = Nothing Which can be used like\nλ\u0026gt; runParser (parseCond (== 'a')) \u0026quot;abcd\u0026quot; Just ('a',\u0026quot;bcd\u0026quot;) As you can see, parser consumed one char and returned rest of the string unchanged. If predicate return False then parsing fails:\nλ\u0026gt; runParser (parseCond (== 'a')) \u0026quot;bda\u0026quot; Nothing Since it will be required to parse single characters a lot, let\u0026rsquo;s define simple wrapper for parsing one character:\nparseChar :: Char -\u0026gt; Parser Char parseChar x = parseCond (== x) Next thing it\u0026rsquo;s required to implement is string parser. A function to parse a string has type f :: [Char] -\u0026gt; Parser [Char] and we already have Parser Char. There should be a way to convert one to another! Hoogle points out there a traverse function, which has following signature:\nclass (Functor t, Foldable t) =\u0026gt; Traversable t where traverse :: Applicative f =\u0026gt; (a -\u0026gt; f b) -\u0026gt; t a -\u0026gt; f (t b) Since strings are just list of Char, and list implements Traversable, this function does exactly what we want. If we change t to [], f to Parser and a and b to Char:\ntraverse :: Applicative Parser =\u0026gt; (Char -\u0026gt; Parser Char) -\u0026gt; [Char] -\u0026gt; Parser ([Char]) Bingo! There is one small problem left \u0026ndash; Parser should implement Applicative.\nMaking parser applicative Let\u0026rsquo;s look what Applicative is. Ghci says:\nλ\u0026gt; :info Applicative type Applicative :: (* -\u0026gt; *) -\u0026gt; Constraint class Functor f =\u0026gt; Applicative f where pure :: a -\u0026gt; f a (\u0026lt;*\u0026gt;) :: f (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b GHC.Base.liftA2 :: (a -\u0026gt; b -\u0026gt; c) -\u0026gt; f a -\u0026gt; f b -\u0026gt; f c (*\u0026gt;) :: f a -\u0026gt; f b -\u0026gt; f b (\u0026lt;*) :: f a -\u0026gt; f b -\u0026gt; f a {-# MINIMAL pure, ((\u0026lt;*\u0026gt;) | liftA2) #-} To Parser type to be applicative it should be a Functor. Ok, but what is Functor?\ntype Functor :: (* -\u0026gt; *) -\u0026gt; Constraint class Functor f where fmap :: (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b (\u0026lt;$) :: a -\u0026gt; f b -\u0026gt; f a {-# MINIMAL fmap #-} To be a Functor instance, Parser type should implement one function called fmap. Let\u0026rsquo;s do it!\nFunctor To better understand what specific typeclasse does, I like to see what other types implement it and play a bit with them. Lucky me, Maybe implements Functor.\nfmap has following signature fmap :: (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b, which means it \u0026ldquo;injects\u0026rdquo; a function inside of a container, that contains a and produces new container that contains b. As an example for Maybe:\nλ\u0026gt; fmap (+ 1) (Just 1) Just 2 λ\u0026gt; fmap (+ 1) (Nothing) Nothing λ\u0026gt; fmap ord (Just 'a') Just 97 If you are familiar with Rust, fmap is like and_then() for Options. For our Parser type it means, that it\u0026rsquo;s will be possible to change produced value to another one in case of successful parsing.\nFunctor instance looks like:\ninstance Functor Parser where fmap fn (Parser f) = Parser ( \\x -\u0026gt; case f x of Just (val, other) -\u0026gt; Just (fn val, other) Nothing -\u0026gt; Nothing ) Also it can be rewritten more cleanly in do notation, since Maybe implement Monad\ninstance Functor Parser where fmap fn (Parser f) = Parser ( \\x -\u0026gt; do (v, other) \u0026lt;- f x return (fn v, other) ) Now it\u0026rsquo;s possible to do following:\nλ\u0026gt; runParser (fmap ord (parseChar 'a')) \u0026quot;abc\u0026quot; Just (97,\u0026quot;bc\u0026quot;) ord was \u0026ldquo;injected\u0026rdquo; into Parser to produce ASCII number out of parsed \u0026lsquo;a\u0026rsquo;. Also note that fancy looking \u0026lt;$\u0026gt; operator is an alias for fmap. Haskell people like using esoteric symbols for operators for some reason.\nApplicative Since Parser now implements Functor, it\u0026rsquo;s possible to implement Applicative instance for it. Recap that it\u0026rsquo;s requied to implement 2 following functions\npure :: a -\u0026gt; f a (\u0026lt;*\u0026gt;) :: f (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b Let\u0026rsquo;s start with pure. This function just \u0026ldquo;wraps\u0026rdquo; value into container. For our parser it means not parsing anything and just returning passed value.\npure val = Parser (Just . (val,)) Next thing is more complex. \u0026lt;*\u0026gt; accepts function wrapped into container and applies it to another container, that holds a value. To better understand what\u0026rsquo;s going on, that\u0026rsquo;s how it works with Maybe:\nλ\u0026gt; Just (+ 1) \u0026lt;*\u0026gt; Just 2 Just 3 λ\u0026gt; Just (+ 1) \u0026lt;*\u0026gt; Nothing Nothing Not scary at all: it\u0026rsquo;s just fmap, but function is wrapped into container. Let\u0026rsquo;s implement using do notation right away, since case of spaghetti would be unreadable.\n(Parser fn) \u0026lt;*\u0026gt; (Parser f) = Parser ( \\x -\u0026gt; do (fn', other) \u0026lt;- fn x (v, other') \u0026lt;- f other return (fn' v, other') ) This gives our parser very powerful property \u0026ndash; chaining. Now it\u0026rsquo;s possible to parse strings:\nλ\u0026gt; runParser (fmap (\\old a b -\u0026gt; old ++ [a] ++ [b]) (pure \u0026quot;\u0026quot; :: Parser String) \u0026lt;*\u0026gt; parseChar 'a' \u0026lt;*\u0026gt; parseChar 'b') \u0026quot;abc\u0026quot; Just (\u0026quot;ab\u0026quot;,\u0026quot;c\u0026quot;) Using this kind of construction for parsing string would be really annoying, but this problem is already solved by traverse function, that was mentioned before! So it\u0026rsquo;s possible to define string parser as follows:\nparseString :: String -\u0026gt; Parser String parseString = traverse parseChar And test it:\nλ\u0026gt; runParser (parseString \u0026quot;hello\u0026quot;) \u0026quot;hello, world!\u0026quot; Just (\u0026quot;hello\u0026quot;,\u0026quot;, world!\u0026quot;) Note that applicative gives up another 2 important operators: \u0026lt;* and *\u0026gt;. I understand them as follows \u0026ldquo;chain 2 applicatives, but pick the result of the one the arrow is pointing to.\nAs an example:\nλ\u0026gt; runParser (parseString \u0026quot;hello\u0026quot; \u0026lt;* parseString \u0026quot;world\u0026quot;) \u0026quot;helloworld\u0026quot; Just (\u0026quot;hello\u0026quot;,\u0026quot;\u0026quot;) λ\u0026gt; runParser (parseString \u0026quot;hello\u0026quot; *\u0026gt; parseString \u0026quot;world\u0026quot;) \u0026quot;helloworld\u0026quot; Just (\u0026quot;world\u0026quot;,\u0026quot;\u0026quot;) We will need it for skipping white-spaces, for instance.\nAlternative The only thing left is to implement Alternative instance. Imagine parsing bool value in json. It could be represented via \u0026ldquo;true\u0026rdquo; or \u0026ldquo;false\u0026rdquo;. Current implementation of parser cannot choose between different values, since it parses until it finds mismatch of EOF.\nAlternative is a way to choose between 2 applicatives.\nclass Applicative f =\u0026gt; Alternative f where empty :: f a (\u0026lt;|\u0026gt;) :: f a -\u0026gt; f a -\u0026gt; f a Operator \u0026lt;|\u0026gt; takes two applicatives and chooses one of them. For our parser this means we can try one and if it fails we fall back to another one:\ninstance Alternative Parser where empty = Parser (const Nothing) (Parser fn) \u0026lt;|\u0026gt; (Parser fn') = Parser ( \\x -\u0026gt; case fn x of Nothing -\u0026gt; fn' x Just e -\u0026gt; Just e ) Now it\u0026rsquo;s possible to do something like this:\nλ\u0026gt; runParser (parseString \u0026quot;hello\u0026quot; \u0026lt;|\u0026gt; parseString \u0026quot;world\u0026quot;) \u0026quot;world hello\u0026quot; Just (\u0026quot;world\u0026quot;,\u0026quot; hello\u0026quot;) Parsing Json Skipping spaces Since Json is not space-sensitive format, parser should not take them into account. To skip them we need a parser that just reads all spaces.\nskipSpace :: Parser String skipSpace = parseWhile (parseChar ' ') \u0026lt;|\u0026gt; pure \u0026quot;\u0026quot; There is a function parseWhile which I did not mention, but it is a parser that runs another parser until it does not return an error. Just in case there is spaces at all, there is \u0026lt;|\u0026gt; pure \u0026quot;\u0026quot; fallback which just returns an empty string, indicating that there were no spaces in input string.\nNull The easiest one to parse is Null value. Null value is represented as simple \u0026ldquo;null\u0026rdquo; string.\nparseNull :: Parser Value parseNull = const Null \u0026lt;$\u0026gt; parseString \u0026quot;null\u0026quot; Null parser just parses \u0026ldquo;null\u0026rdquo; string and fmaps result to Null Json value.\nBoolean Boolean is represented with either \u0026ldquo;true\u0026rdquo; or \u0026ldquo;false\u0026rdquo; strings. We can use Alternative property of our parser to choose between \u0026ldquo;true\u0026rdquo; and \u0026ldquo;false\u0026rdquo; values.\nparseBool :: Parser Value parseBool = (\\x -\u0026gt; if x == \u0026quot;true\u0026quot; then Boolean True else Boolean False) \u0026lt;$\u0026gt; (parseString \u0026quot;true\u0026quot; \u0026lt;|\u0026gt; parseString \u0026quot;false\u0026quot;) Number Based on BNF grammar from the beginning of the article, there are 2 types of number: integers and doubles. Let\u0026rsquo;s look at their parsers implementation:\nInteger parsing is quite straightforward: just read characters until they are numbers.\nintParser :: Parser String intParser = parseWhile (parseCond isNumber) Double parser is a bit tricky, but idea is simple. The idea is to look at the floating point number as two integers, separated by \u0026lsquo;.\u0026rsquo; character:\ndoubleParser :: Parser String doubleParser = fmap concat intParser \u0026lt;*\u0026gt; parseString \u0026quot;.\u0026quot; \u0026lt;*\u0026gt; intParser And to handle negative numbers we need another parser that just tries to read \u0026lsquo;-\u0026rsquo; and then double or integer:\nnegativeInt :: Parser String negativeInt = fmap (++) (parseString \u0026quot;-\u0026quot;) \u0026lt;*\u0026gt; (doubleParser \u0026lt;|\u0026gt; intParser) Equipped with these 3 parsers, it\u0026rsquo;s quite easy to write generic parser for any number: just chain them all with \u0026lt;|\u0026gt; a pass result to read function which converts string to a number.\nThe whole number parsing function is shown below:\nparseInt :: Parser Value parseInt = Number . read \u0026lt;$\u0026gt; (skipSpace *\u0026gt; (doubleParser \u0026lt;|\u0026gt; intParserNotFromZero \u0026lt;|\u0026gt; negativeInt)) where intParser, doubleParser, negativeInt :: Parser String negativeInt = fmap (++) (parseString \u0026quot;-\u0026quot;) \u0026lt;*\u0026gt; (doubleParser \u0026lt;|\u0026gt; intParser) intParserNotFromZero = test *\u0026gt; parseWhile (parseCond isNumber) intParser = parseWhile (parseCond isNumber) doubleParser = fmap concat intParser \u0026lt;*\u0026gt; parseString \u0026quot;.\u0026quot; \u0026lt;*\u0026gt; intParser concat a b c = a ++ b ++ c String In Json strings are represented as string in quotation marks. So parser should parse quotation mark and read everthing until the next quotation mark:\nparseStringValue :: Parser Value parseStringValue = String \u0026lt;$\u0026gt; (parseChar '\\\u0026quot;' *\u0026gt; (parseWhile (parseCond (/= '\\\u0026quot;')) \u0026lt;|\u0026gt; pure \u0026quot;\u0026quot;) \u0026lt;* parseChar '\\\u0026quot;') Here we use *\u0026gt; and \u0026lt;* just to ignore parsed quotation marks, since the are not part of the string itself.\nArray Arrays in Json are untyped, so they could contain any types (like tuples in statically typed languages). Array are represented as list of valid Json object separated by \u0026lsquo;,\u0026rsquo; in \u0026lsquo;[]\u0026rsquo; brackets.\nparseArray :: Parser Value parseArray = Array \u0026lt;$\u0026gt; ( parseChar '[' *\u0026gt; ((parseSep (skipSpace *\u0026gt; parseJson \u0026lt;* skipSpace) (parseString \u0026quot;,\u0026quot;)) \u0026lt;|\u0026gt; pure []) \u0026lt;* parseChar ']' ) parseSep is another helper parser (like parseUntil) that adapts 2 parsers: one for a value and one for the separator and returns a list of parsed objects.\nObject Json object is a pairs like collection of pair \u0026quot;name\u0026quot; : \u0026lt;Json\u0026gt;, wrapped with curly braces, where Json is a valid json object.\nFirst of all, let\u0026rsquo;s define pair parser, which will consume string, \u0026lsquo;:\u0026rsquo; and any valid json object.\nparsePair :: Parser (Value, Value) parsePair = Parser ( \\x -\u0026gt; do (str, other) \u0026lt;- runParser parseStringValue x (val, other') \u0026lt;- runParser (skipSpace *\u0026gt; parseChar ':' *\u0026gt; skipSpace *\u0026gt; parseJson) other return ((str, val), other') ) I am using do notation to make code readable, but \u0026lt;*\u0026gt; could be used here as well. Then parsing whole Json object is trivial. We need to parse curly braces and parse pairs separated by \u0026lsquo;,\u0026rsquo;.\nparseObject :: Parser Value parseObject = Object \u0026lt;$\u0026gt; ( parseChar '{' *\u0026gt; ((parseSep (skipSpace *\u0026gt; parsePair \u0026lt;* skipSpace) (parseString \u0026quot;,\u0026quot;)) \u0026lt;|\u0026gt; pure []) \u0026lt;* parseChar '}' ) Conclusion I was very impressed that whole parser is only 150 LoC. I am new to FP world, so I guess, it could be done even with less code, but at the end I learned a lot about Haskell types and stuff.\nThe whole code could be found here\n","date":"2024-05-10","permalink":"https://pskrgag.github.io/post/json/","tags":["haskell","parsing"],"title":"Subset of JSON parser in 150 lines of Haskell code"},{"content":"Introduction In this blog post I\u0026rsquo;ll share how I wrote simple address sanitizer as LLVM pass. Since there are a lot of info about how to build and write LLVM passes, I assume reader is familiar with LLVM basics. If it is not the case, please, read [1] [2] and come back later.\nAddress sanitizer Background Address sanitizer is a tool which can detect memory corruption bugs at runtime. There are 3 methods to detect memory corruption bugs at runtime:\nSoftware-based Hardware-based Software-based with help of hardware The easiest one to understand is software based, that relies on compiler instrumentation and runtime library. So the main topic of this blog post will be software based ASAN.\nTo understand how sanitizer works let\u0026rsquo;s take a look at state-of-art clang ASAN. Let\u0026rsquo;s write simple program which will do OOB stack access\nint main(void) { int array[10]; array[11] = 10; } Then compile with ASAN enabled and run it!\n$ clang main.c -fsanitize=address -o main $ ./main ================================================================= ==276729==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffe87b25d4 at pc 0x0000005116f4 bp 0x7fffe87b2570 sp 0x7fffe87b2568 WRITE of size 4 at 0x7fffe87b25d4 thread T0 #0 0x5116f3 in main (/home/paskripkin/Documents/compiler_ws/asan_test/a.out+0x5116f3) (BuildId: 55394075f1634f74ec7c28e272ffa4ab3581f616) #1 0x7fbc9d62950f in __libc_start_call_main (/lib64/libc.so.6+0x2950f) (BuildId: 8257ee907646e9b057197533d1e4ac8ede7a9c5c) #2 0x7fbc9d6295c8 in __libc_start_main@GLIBC_2.2.5 (/lib64/libc.so.6+0x295c8) (BuildId: 8257ee907646e9b057197533d1e4ac8ede7a9c5c) #3 0x41c2f4 in _start (/home/paskripkin/Documents/compiler_ws/asan_test/a.out+0x41c2f4) (BuildId: 55394075f1634f74ec7c28e272ffa4ab3581f616) Address 0x7fffe87b25d4 is located in stack of thread T0 at offset 84 in frame #0 0x5115ef in main (/home/paskripkin/Documents/compiler_ws/asan_test/a.out+0x5115ef) (BuildId: 55394075f1634f74ec7c28e272ffa4ab3581f616) This frame has 1 object(s): [32, 72) 'array' \u0026lt;== Memory access at offset 84 overflows this variable HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork (longjmp and C++ exceptions *are* supported) SUMMARY: AddressSanitizer: stack-buffer-overflow (/home/paskripkin/Documents/compiler_ws/asan_test/a.out+0x5116f3) (BuildId: 55394075f1634f74ec7c28e272ffa4ab3581f616) in main Shadow bytes around the buggy address: 0x10007d0ee460: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10007d0ee470: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10007d0ee480: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10007d0ee490: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10007d0ee4a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 =\u0026gt;0x10007d0ee4b0: f1 f1 f1 f1 00 00 00 00 00 f3[f3]f3 f3 f3 f3 f3 0x10007d0ee4c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10007d0ee4d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10007d0ee4e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10007d0ee4f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10007d0ee500: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb ==276729==ABORTING Very long splat says that program did something really bad \u0026ndash; stack buffer overflow. Don\u0026rsquo;t bother with magic hex numbers in the splat above, I will come back to them later.\nImplementation details As I mentioned earlier software based ASAN relies on compiler instrumentation, so let\u0026rsquo;s look under the hood at generated LLVM IR.\n$ clang -fsanitize=address -emit-llvm -c main1.c $ llvm-dis \u0026lt; main1.bc | rg asan ... %asan_local_stack_base = alloca i64, align 8 %0 = load i32, i32* @__asan_option_detect_stack_use_after_return, align 4 %3 = call i64 @__asan_stack_malloc_1(i64 128) store i64 %10, i64* %asan_local_stack_base, align 8 store i64 ptrtoint ([16 x i8]* @___asan_gen_ to i64), i64* %15, align 8 ... As you may see LLVM inserted a bunch of callbacks into the code. IIUC clang uses inline instrumentation, so finding out exact places of runtime checks is a bit problematic. Anyways the general idea is simple: before any load or store make a call to a hook which will check if following access is valid. In terms of LLVM IR it may look like\ncall void @__runtime_check_access(ptr %addr, i32 4) store i32 %val, ptr %addr, align 4 The only thing left to discover is how to implement runtime check. The idea can be found in paper [3], I will just give brief summary.\nTo check memory state, runtime library creates a memory space where each byte of the address space is tracked. That memory space is called shadow memory. Any byte of the program can be in 2 different states: accessible and not-accessible. Making shadow memory an 1:1 mapping would be overkill and would not work with application with high memory usage. That\u0026rsquo;s why shadow memory is 1:8 mapping where each byte of the shadow memory maps to 8 bytes of the program memory.\nEach byte of shadow memory can be in 9 different states: k (1 ≤ k ≤ 7) means k bytes are accessible; any negative number means whole 8-byte block is unaccessible.\nFinding corresponding shadow byte to address is simple:\nShadowAddr = (Addr \u0026gt;\u0026gt; 3) + Offset; Then ShadowAddr can be used to determine if access is valid or not\nif (access_size == 8) { ShadowAddr = (Addr \u0026gt;\u0026gt; 3) + Offset; if (*ShadowAddr != 0) ReportAndCrash(Addr); } else { ShadowAddr = (Addr \u0026gt;\u0026gt; 3) + Offset; k = *ShadowAddr; if (k != 0 \u0026amp;\u0026amp; ((Addr \u0026amp; 7) + AccessSize \u0026gt; k)) ReportAndCrash(Addr); } Since now we know basics about how address sanitizer works, let\u0026rsquo;s write our dumb one\nWriting own address sanitizer To build a sanitizer it\u0026rsquo;s required to implement 2 parts\nLLVM pass to insert instrumentation runtime library to manage shadow memory LLVM pass Let\u0026rsquo;s start with LLVM pass. First of all let\u0026rsquo;s\nLinks [1] LLVM docs https://llvm.org/docs/WritingAnLLVMNewPMPass.html\n[2] Pass example https://github.com/alexjung/Writing-an-LLVM-Pass-using-the-new-PassManager\n[3] Address sanitizer papper https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf\n","date":"2023-08-30","permalink":"https://pskrgag.github.io/post/sanitizer/","tags":["llvm"],"title":"Writing simple address-sanitizer llvm pass"},{"content":"Intro Since the only thing I can do is fixing random kernel bugs, I\u0026rsquo;d like to show how to understand and fix bugs reported by syzkaller by example. There are a lot of open bugs, so anyone who is looking for first contribution should try it! Most of the bugs really common, but in most cases maintainers do not have much time to fix bugs. It\u0026rsquo;s great chance to step in and join kernel community by just adding missing validation check or something\nConfiguration To fix a bug in the Linux kernel you should at least download the sources. The official tree locates here and you can download it like this\n$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git Next step is configure git send-email. Linux kernel development process is based on plain text email. No github pull requests or something. Brutal old-school emails in plain text. Add following configuration into your ~/.gitconfig. Mine is for gmail accounts.\n[sendemail] from = Name Surname \u0026lt;email@examle.com\u0026gt; smtpserver = smtp.gmail.com smtpuser = email@examle.com smtpencryption = tls smtppass = [pass] smtpserverport = 587 confirm = auto If you use 2 factor authentication smtppass field should be unique app password. You can create it on gmail security page.\nGreat! You have set up all needed environment.\nExample of bug fixing For this example I took this bug. It\u0026rsquo;s very simple, but it was open for 120 days! Let\u0026rsquo;s take a look at the full report.\n------------[ cut here ]------------ WARNING: CPU: 1 PID: 3603 at drivers/i2c/i2c-core-base.c:2178 __i2c_transfer+0xa14/0x17c0 drivers/i2c/i2c-core-base.c:2178 drivers/i2c/i2c-core-base.c:2178 Modules linked in: CPU: 1 PID: 3603 Comm: syz-executor029 Not tainted 5.16.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 RIP: 0010:__i2c_transfer+0xa14/0x17c0 drivers/i2c/i2c-core-base.c:2178 drivers/i2c/i2c-core-base.c:2178 Code: 0f 94 c7 31 ff 44 89 fe e8 e9 ab 9b fb 45 84 ff 0f 84 26 fd ff ff e8 fb a7 9b fb e8 65 3b 24 fb e9 17 fd ff ff e8 ec a7 9b fb \u0026lt;0f\u0026gt; 0b 41 bc ea ff ff ff e9 9e fd ff ff e8 da a7 9b fb 44 89 ee bf RSP: 0018:ffffc90002aafce8 EFLAGS: 00010293 RAX: 0000000000000000 RBX: 0000000000000010 RCX: 0000000000000000 RDX: ffff88801c0f3a00 RSI: ffffffff85dc09e4 RDI: 0000000000000003 RBP: ffff88814a058b58 R08: 0000000000000000 R09: ffffffff8ff74ac7 R10: ffffffff85dc0008 R11: 0000000000000000 R12: 0000000000000010 R13: 0000000000000000 R14: ffff88814a058b78 R15: 0000000000000000 FS: 0000000000000000(0000) GS:ffff8880b9d00000(0063) knlGS:0000000056cc62c0 CS: 0010 DS: 002b ES: 002b CR0: 0000000080050033 CR2: 0000000020000000 CR3: 00000000773de000 CR4: 00000000003506e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: \u0026lt;TASK\u0026gt; i2c_transfer+0x1e6/0x3e0 drivers/i2c/i2c-core-base.c:2269 drivers/i2c/i2c-core-base.c:2269 i2cdev_ioctl_rdwr+0x583/0x6a0 drivers/i2c/i2c-dev.c:297 drivers/i2c/i2c-dev.c:297 compat_i2cdev_ioctl+0x419/0x4f0 drivers/i2c/i2c-dev.c:561 drivers/i2c/i2c-dev.c:561 __do_compat_sys_ioctl+0x1c7/0x290 fs/ioctl.c:972 fs/ioctl.c:972 do_syscall_32_irqs_on arch/x86/entry/common.c:112 [inline] do_syscall_32_irqs_on arch/x86/entry/common.c:112 [inline] arch/x86/entry/common.c:178 __do_fast_syscall_32+0x65/0xf0 arch/x86/entry/common.c:178 arch/x86/entry/common.c:178 do_fast_syscall_32+0x2f/0x70 arch/x86/entry/common.c:203 arch/x86/entry/common.c:203 entry_SYSENTER_compat_after_hwframe+0x4d/0x5c RIP: 0023:0xf7e6e549 Code: 03 74 c0 01 10 05 03 74 b8 01 10 06 03 74 b4 01 10 07 03 74 b0 01 10 08 03 74 d8 01 00 00 00 00 00 51 52 55 89 e5 0f 34 cd 80 \u0026lt;5d\u0026gt; 5a 59 c3 90 90 90 90 8d b4 26 00 00 00 00 8d b4 26 00 00 00 00 RSP: 002b:00000000fffc8b7c EFLAGS: 00000246 ORIG_RAX: 0000000000000036 RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 0000000000000707 RDX: 00000000200003c0 RSI: 00000000fffc8bd0 RDI: 00000000f7f15000 RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000 R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000 \u0026lt;/TASK\u0026gt; ---------------- Code disassembly (best guess): 0:\t03 74 c0 01 add 0x1(%rax,%rax,8),%esi 4:\t10 05 03 74 b8 01 adc %al,0x1b87403(%rip) # 0x1b8740d a:\t10 06 adc %al,(%rsi) c:\t03 74 b4 01 add 0x1(%rsp,%rsi,4),%esi 10:\t10 07 adc %al,(%rdi) 12:\t03 74 b0 01 add 0x1(%rax,%rsi,4),%esi 16:\t10 08 adc %cl,(%rax) 18:\t03 74 d8 01 add 0x1(%rax,%rbx,8),%esi 1c:\t00 00 add %al,(%rax) 1e:\t00 00 add %al,(%rax) 20:\t00 51 52 add %dl,0x52(%rcx) 23:\t55 push %rbp 24:\t89 e5 mov %esp,%ebp 26:\t0f 34 sysenter 28:\tcd 80 int $0x80 * 2a:\t5d pop %rbp \u0026lt;-- trapping instruction 2b:\t5a pop %rdx 2c:\t59 pop %rcx 2d:\tc3 retq 2e:\t90 nop 2f:\t90 nop 30:\t90 nop 31:\t90 nop 32:\t8d b4 26 00 00 00 00 lea 0x0(%rsi,%riz,1),%esi 39:\t8d b4 26 00 00 00 00 lea 0x0(%rsi,%riz,1),%esi ---------------- Code disassembly (best guess): 0:\t03 74 c0 01 add 0x1(%rax,%rax,8),%esi 4:\t10 05 03 74 b8 01 adc %al,0x1b87403(%rip) # 0x1b8740d a:\t10 06 adc %al,(%rsi) c:\t03 74 b4 01 add 0x1(%rsp,%rsi,4),%esi 10:\t10 07 adc %al,(%rdi) 12:\t03 74 b0 01 add 0x1(%rax,%rsi,4),%esi 16:\t10 08 adc %cl,(%rax) 18:\t03 74 d8 01 add 0x1(%rax,%rbx,8),%esi 1c:\t00 00 add %al,(%rax) 1e:\t00 00 add %al,(%rax) 20:\t00 51 52 add %dl,0x52(%rcx) 23:\t55 push %rbp 24:\t89 e5 mov %esp,%ebp 26:\t0f 34 sysenter 28:\tcd 80 int $0x80 * 2a:\t5d pop %rbp \u0026lt;-- trapping instruction 2b:\t5a pop %rdx 2c:\t59 pop %rcx 2d:\tc3 retq 2e:\t90 nop 2f:\t90 nop 30:\t90 nop 31:\t90 nop 32:\t8d b4 26 00 00 00 00 lea 0x0(%rsi,%riz,1),%esi 39:\t8d b4 26 00 00 00 00 lea 0x0(%rsi,%riz,1),%esi Report says there is a WARN_ON at drivers/i2c/i2c-core-base.c:2178. Let\u0026rsquo;s take a look what kind of warning it is.\nif (WARN_ON(!msgs || num \u0026lt; 1)) return -EINVAL; Hm, looks like somebody passed wrong arguments. Where these numbers come from? This question can be easily answered by looking at stack trace.\ni2c_transfer+0x1e6/0x3e0 drivers/i2c/i2c-core-base.c:2269 drivers/i2c/i2c-core-base.c:2269 i2cdev_ioctl_rdwr+0x583/0x6a0 drivers/i2c/i2c-dev.c:297 drivers/i2c/i2c-dev.c:297 compat_i2cdev_ioctl+0x419/0x4f0 drivers/i2c/i2c-dev.c:561 drivers/i2c/i2c-dev.c:561 __do_compat_sys_ioctl+0x1c7/0x290 fs/ioctl.c:972 fs/ioctl.c:972 do_syscall_32_irqs_on arch/x86/entry/common.c:112 [inline] do_syscall_32_irqs_on arch/x86/entry/common.c:112 [inline] arch/x86/entry/common.c:178 __do_fast_syscall_32+0x65/0xf0 arch/x86/entry/common.c:178 arch/x86/entry/common.c:178 do_fast_syscall_32+0x2f/0x70 arch/x86/entry/common.c:203 arch/x86/entry/common.c:203 entry_SYSENTER_compat_after_hwframe+0x4d/0x5c First 6 entries are common syscall kernel path, so we can simply ignore them. Next one is compat_i2cdev_ioctl. This function is ioctl handler for /dev/i2c-* devices. We are not interested in purpose of this devices. Something related to i2c. What we really interested in is what this function does \u0026ndash; it copies some data from user-space and pass it deeper into i2c stack.\n519 static long compat_i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg) 520 { 521 struct i2c_client *client = file-\u0026gt;private_data; 522 unsigned long funcs; 523 switch (cmd) { 524 case I2C_FUNCS: 525 funcs = i2c_get_functionality(client-\u0026gt;adapter); 526 return put_user(funcs, (compat_ulong_t __user *)arg); 527 case I2C_RDWR: { 528 struct i2c_rdwr_ioctl_data32 rdwr_arg; 529 struct i2c_msg32 __user *p; 530 struct i2c_msg *rdwr_pa; 531 int i; 532 533 if (copy_from_user(\u0026amp;rdwr_arg, 534 (struct i2c_rdwr_ioctl_data32 __user *)arg, 535 sizeof(rdwr_arg))) 536 return -EFAULT; 537 538 if (rdwr_arg.nmsgs \u0026gt; I2C_RDWR_IOCTL_MAX_MSGS) 539 return -EINVAL; 540 541 rdwr_pa = kmalloc_array(rdwr_arg.nmsgs, sizeof(struct i2c_msg), 542 GFP_KERNEL); 543 if (!rdwr_pa) 544 return -ENOMEM; 545 546 p = compat_ptr(rdwr_arg.msgs); 547 for (i = 0; i \u0026lt; rdwr_arg.nmsgs; i++) { 548 struct i2c_msg32 umsg; 549 if (copy_from_user(\u0026amp;umsg, p + i, sizeof(umsg))) { 550 kfree(rdwr_pa); 551 return -EFAULT; 552 } 553 rdwr_pa[i] = (struct i2c_msg) { 554 .addr = umsg.addr, 555 .flags = umsg.flags, 556 .len = umsg.len, 557 .buf = compat_ptr(umsg.buf) 558 }; 559 } 560 561 return i2cdev_ioctl_rdwr(client, rdwr_arg.nmsgs, rdwr_pa); 562 } 563 case I2C_SMBUS: { 564 struct i2c_smbus_ioctl_data32 data32; 565 if (copy_from_user(\u0026amp;data32, 566 (void __user *) arg, 567 sizeof(data32))) 568 return -EFAULT; 569 return i2cdev_ioctl_smbus(client, data32.read_write, 570 data32.command, 571 data32.size, 572 compat_ptr(data32.data)); 573 } 574 default: 575 return i2cdev_ioctl(file, cmd, arg); 576 } 577 } Next stack trace entry is i2cdev_ioctl_rdwr. From just looking at the code we can say, that reproducer passed I2C_RDWR as cmd. Take a closer look at the call\nreturn i2cdev_ioctl_rdwr(client, rdwr_arg.nmsgs, rdwr_pa); rdwr_arg.nmsgs is user controlled value. It\u0026rsquo;s obvious from copy_from_user call on line 533. Ok, let\u0026rsquo;s go down to stack. What does i2cdev_ioctl_rdwr? I won\u0026rsquo;t copy-paste full function, I will cut it to very simplified form\nstatic noinline int i2cdev_ioctl_rdwr(struct i2c_client *client, unsigned nmsgs, struct i2c_msg *msgs) { u8 __user **data_ptrs; int i, res; data_ptrs = kmalloc_array(nmsgs, sizeof(u8 __user *), GFP_KERNEL); if (data_ptrs == NULL) { kfree(msgs); return -ENOMEM; } res = 0; for (i = 0; i \u0026lt; nmsgs; i++) { /* something */ } res = i2c_transfer(client-\u0026gt;adapter, msgs, nmsgs); \u0026lt;--- Hm??? /* something else */ } Do you see a problem? Let\u0026rsquo;s go back to root case of the bug. There is following warning in i2c_transfer.\nif (WARN_ON(!msgs || num \u0026lt; 1)) return -EINVAL; And as we discovered above msgs is user-controlled value. Code must validate passed arguments before passing them down to i2c transfer functions. compat_i2cdev_ioctl check only for nmsgs max value, but not for nmsgs being zero.\nI come up with this solution\ndiff --git a/drivers/i2c/i2c-dev.c b/drivers/i2c/i2c-dev.c index bce0e8bb7852..cf5d049342ea 100644 --- a/drivers/i2c/i2c-dev.c +++ b/drivers/i2c/i2c-dev.c @@ -535,6 +535,9 @@ static long compat_i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned lo sizeof(rdwr_arg))) return -EFAULT; + if (!rdwr_arg.msgs || rdwr_arg.nmsgs == 0) + return -EINVAL; + if (rdwr_arg.nmsgs \u0026gt; I2C_RDWR_IOCTL_MAX_MSGS) return -EINVAL; How to test your fix The easiest way is delegate testing to syzbot. Full communication guide can be found here, but we need only one command.\n#syz test: \u0026lt;tree\u0026gt; \u0026lt;branch or commit SHA\u0026gt; For upstream bug use\n#syz test git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git master Just send an email to mail address that can be found on bug page\nAnd attach your patch to the email (as file or as plain text). Syzbot will build the kernel and run reproducer for some time. If it won\u0026rsquo;t hit any bugs you will receive Reported-and-tested-by tag.\nA bit harder way is to use qemu. You will need to build the kernel by yourself and it\u0026rsquo;s topic for separate post.\nHow to format send your patch Commit your changes using\n$ git add -u $ git commit -s -s is important! This argument automatically adds Signed-off-by with your email and name to commit log. Patches w/o Signed-off-by tag will be automatically rejected. It doesn\u0026rsquo;t matter if change is correct or not. 1st line is the subject of your patch. The format is following:\n\u0026lt;subsystem name\u0026gt;: [\u0026lt;subsystem part if present\u0026gt;:] \u0026lt;short description of the change\u0026gt; For this example:\ni2c: validate user data in compat ioctl The bug itself is in i2c core, so there is no need in specifying subsystem part. Subject line should be less than 75 characters in length, but it\u0026rsquo;s not strict rule. The main rule is \u0026ndash; subject must be small and should describe the change. Put blank line after the subject line and describe the change in more details. Add why this change is needed, what\u0026rsquo;s the root case and how you have fixed it. You can add anything you feel related to the patch. Put blank line after commit message and before tags. It makes patches look more nice. Do not forget to add Reported-by tag from bug page or Reported-and-tested-by received from syzbot\nExample patch message\ni2c: validate user data in compat ioctl\t\u0026lt;- Subject line \u0026lt;- Blank line before commit message Wrong user data may cause warning in i2c_transfer(), ex: zero msgs. Userspace should not be able to trigger warnings, so this patch adds validation checks for user data in compact ioctl to prevent reported warnings \u0026lt;- Blank line before tags Reported-and-tested-by: syzbot+e417648b303855b91d8a@syzkaller.appspotmail.com Fixes: 7d5cb45655f2 (\u0026quot;i2c compat ioctls: move to -\u0026gt;compat_ioctl()\u0026quot;) Signed-off-by: Pavel Skripkin \u0026lt;paskripkin@gmail.com\u0026gt; FWIW, commit message itself should be formatted to 75 chars per line. Some maintainers might get mad at you for wrong formatting. The full guide for submitting patches can be found here.\nOk, your patch is formatted in your local tree. How to post it to mailing lists? First of all use\n$ git format-patch HEAD~ 0001-i2c-validate-user-data-in-compat-ioctl.patch $ command. It will create formatted patch email which you can send using git send-email command. Do not hurry with sending it. Smart kernel developers created a script for finding common mistakes in patches. Do not forget to use it before posting a patch. Simply run this command from kernel root directory\n$ ./scripts/checkpatch.pl 0001-i2c-validate-user-data-in-compat-ioctl.patch WARNING: Possible unwrapped commit description (prefer a maximum 75 chars per line) #11: Reported-and-tested-by: syzbot+e417648b303855b91d8a@syzkaller.appspotmail.com total: 0 errors, 1 warnings, 9 lines checked NOTE: For some of the reported defects, checkpatch may be able to mechanically convert to the typical style using --fix or --fix-inplace. 0001-i2c-validate-user-data-in-compat-ioctl.patch has style problems, please review. NOTE: If any of the errors are false positives, please report them to the maintainer, see CHECKPATCH in MAINTAINERS. There is one warning. It can be ignored, because tags must be one-liners. So looks like our patch is ready for submittion. The last thing we need the list of people interested in our change. There is also a script for that. It\u0026rsquo;s called get_maintainer.pl. Example of usage:\n$ ./scripts/get_maintainer.pl 0001-i2c-validate-user-data-in-compat-ioctl.patch Wolfram Sang \u0026lt;wsa@kernel.org\u0026gt; (maintainer:I2C SUBSYSTEM) Al Viro \u0026lt;viro@zeniv.linux.org.uk\u0026gt; (blamed_fixes:1/1=100%) linux-i2c@vger.kernel.org (open list:I2C SUBSYSTEM) linux-kernel@vger.kernel.org (open list) Not so many people\u0026hellip; And the last step is send the patch. Just put all needed emails in git send-email arguments and press enter. Like this\n$ git send-email \\ \u0026gt; --to=wsa@kernel.org \\ \u0026gt; --to=viro@zeniv.linux.org.uk \\ \u0026gt; --cc=linux-i2c@vger.kernel.org \\ \u0026gt; --cc=linux-kernel@vger.kernel.org \\ \u0026gt; 0001-i2c-validate-user-data-in-compat-ioctl.patch You can check https://lore.kernel.org/ to see if patch reached the lists. Mine can be found here. If your patch reached the lists then you just need to sit down and relax. Sometimes maintainers reply within a day, but average waiting time for a feedback is 7-8 days. Don\u0026rsquo;t hurry, maintainers are very busy people, so no need to rush.\nGood luck in bug fixing and thanks for reading!\n","date":"2022-03-18","permalink":"https://pskrgag.github.io/post/test_post/","tags":["linux kernel"],"title":"How to fix a bug in the Linux kernel"}]